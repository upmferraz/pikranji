<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pikranji - The Kanji Picross</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos Base e Otimizações de Tamanho */
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; overflow: auto; }
        
        .board-container { 
            width: 90vw; 
            height: 90vw; 
            max-width: 600px; 
            max-height: 600px; 
            display: grid; 
            grid-template-columns: min-content 1fr; 
            grid-template-rows: min-content 1fr; 
            gap: 0px; 
            touch-action: none; 
        }

        .clues-top { grid-column: 2 / 3; grid-row: 1 / 2; display: flex; justify-content: space-around; }
        .clues-left { grid-column: 1 / 2; grid-row: 2 / 3; display: flex; flex-direction: column; justify-content: space-around; align-items: flex-end; }
        .clue-cell { color: #4b5563; font-weight: 600; display: flex; align-items: center; justify-content: center; padding: 0 4px; text-align: center; font-size: 0.75rem; }
        .clues-top .clue-cell { flex-direction: column; padding: 4px 0; width: 100%; }
        .clues-left .clue-cell { padding: 0 4px; height: 100%; }
        /* NOVO ESTILO: Para Pistas Concluídas */
        .clue-cell.completed span {
            color: #9ca3af; /* Cinzento mais claro */
            text-decoration: line-through; /* Riscar o número */
            opacity: 0.7;
        }

        .game-grid { grid-column: 2 / 3; grid-row: 2 / 3; display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr); gap: 0px; border-top: 1px solid #d1d5db; border-left: 1px solid #d1d5db; }
        .cell {
            width: 100%; height: 100%; border-right: 1px solid #d1d5db; border-bottom: 1px solid #d1d5db;
            background-color: #f3f4f6; cursor: pointer; transition: background-color 0.1s;
            -webkit-tap-highlight-color: transparent; touch-action: none;
        }
        .cell.filled { background-color: #374151; border-color: #374151; }
        .cell.marked::before { content: '×'; color: #9ca3af; display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; font-size: 0.6em; line-height: 1; }
        .control-btn.active { background-color: #4f46e5; color: white; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); }
        
        /* MINI-MAPA (Mantido) */
        #mini-map-container {
            position: fixed; top: 10px; right: 10px; width: 150px; height: 150px; background-color: white;
            border: 3px solid #4f46e5; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 900; overflow: hidden; opacity: 0; transition: opacity 0.2s ease-in-out;
        }
        #mini-map-grid {
            display: grid; grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr);
            width: 100%; height: 100%; gap: 0px; 
        }
        .mini-cell { background-color: #f3f4f6; border: 0.5px solid #d1d5db; transition: background-color 0.1s; }
        .mini-filled { background-color: #374151 !important; border-color: #374151 !important; }
        .mini-highlight { outline: 2px solid red; outline-offset: -2px; }

        @media (min-width: 600px) { #mini-map-container { display: none !important; } }

        /* OTIMIZAÇÕES PARA TELEMÓVEIS (TAMANHO MÁXIMO DO QUADRO) */
        @media (max-width: 480px) {
            .board-container { 
                width: 98vw; 
                height: 98vw; 
                gap: 0px; 
            }
            .clue-cell { 
                /* Fonte das pistas reduzida ao máximo */
                font-size: 0.35rem; 
                padding: 0 1px; 
            }
            .clues-top .clue-cell { padding: 0px 0; }
            .clues-left .clue-cell { padding: 0 0px; }
            .cell.marked::before { font-size: 1.2em; }
            .control-btn, #reset-btn, #solve-btn, #next-btn, #modal-next-btn { padding: 0.7rem 1.4rem; font-size: 1rem; }
            #controls { gap: 0.5rem; }
        }
    </style>
</head>
<body class="bg-stone-100 p-4">

    <div id="mini-map-container" style="opacity: 0;">
        <div id="mini-map-grid"></div>
    </div>
    
    <div id="app-container" class="w-full max-w-4xl mx-auto flex flex-col items-center">
        
        <header class="text-center mb-6">
            <h1 class="text-4xl md:text-5xl font-bold text-stone-900">Kanji Picross</h1>
            <p class="text-stone-600 mt-2">Resolva o puzzle para revelar o Kanji!</p>
        </header>

        <main class="w-full flex flex-col items-center bg-white p-6 rounded-2xl shadow-lg">
            
            <div id="kanji-info" class="mb-4 text-center">
                <p class="text-lg text-stone-500">Significado:</p>
                <h2 id="kanji-meaning" class="text-3xl font-semibold text-indigo-600"></h2>
            </div>
            
            <div id="game-board-container" class="w-full flex items-center justify-center mb-6">
                <div id="game-board" class="board-container"></div>
            </div>

            <div id="controls" class="flex flex-wrap items-center justify-center gap-4">
                <div class="flex gap-2 rounded-lg p-1 bg-stone-200">
                    <button id="fill-btn" class="control-btn active px-4 py-2 rounded-md text-lg font-semibold transition-all duration-200">
                        ⬛
                    </button>
                    <button id="mark-btn" class="control-btn px-4 py-2 rounded-md text-lg font-semibold transition-all duration-200">
                        ❌
                    </button>
                </div>
                <button id="reset-btn" class="px-5 py-3 bg-stone-500 text-white rounded-lg font-semibold shadow hover:bg-stone-600 transition-colors">Reiniciar</button>
                <button id="solve-btn" class="px-5 py-3 bg-teal-500 text-white rounded-lg font-semibold shadow hover:bg-teal-600 transition-colors">Resolver</button>
                <button id="next-btn" class="px-5 py-3 bg-indigo-600 text-white rounded-lg font-semibold shadow hover:bg-indigo-700 transition-colors">Próximo Kanji</button>
            </div>

        </main>
    </div>

    <div id="win-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 transition-opacity duration-300 opacity-0 pointer-events-none">
        <div class="bg-white rounded-2xl p-8 text-center shadow-2xl transform scale-95 transition-all duration-300">
            <h2 class="text-2xl font-bold mb-2">Parabéns!</h2>
            <p class="text-stone-600 mb-4">Você revelou o Kanji para:</p>
            <div id="win-kanji" class="text-8xl font-black text-indigo-600 mb-4"></div>
            <p id="win-meaning" class="text-2xl font-semibold mb-6"></p>
            <button id="modal-next-btn" class="w-full px-6 py-3 bg-indigo-600 text-white rounded-lg font-semibold shadow hover:bg-indigo-700 transition-colors">Próximo Desafio</button>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const board = document.getElementById('game-board');
            const kanjiMeaning = document.getElementById('kanji-meaning');
            const fillBtn = document.getElementById('fill-btn');
            const markBtn = document.getElementById('mark-btn');
            const resetBtn = document.getElementById('reset-btn');
            const solveBtn = document.getElementById('solve-btn');
            const nextBtn = document.getElementById('next-btn');
            const winModal = document.getElementById('win-modal');
            const modalNextBtn = document.getElementById('modal-next-btn');
            const winKanji = document.getElementById('win-kanji');
            const winMeaning = document.getElementById('win-meaning');
            
            const miniMapContainer = document.getElementById('mini-map-container');

            let puzzles = []; 
            let currentGrid = [];
            const gridSize = 15;
            let currentTool = 'fill';
            
            // Variáveis de Interação Atualizadas
            let isDragging = false;
            let isTap = false; 
            let tapCell = null; 
            let cells;
            let dragTargetState = null; 
            
            // NOVAS VARIÁVEIS PARA LONG PRESS
            let pressTimeout = null;
            let longPressExecuted = false; 

            // =========================================================================
            // VARIÁVEIS PARA PISTAS E ESTADO DO JOGO
            // =========================================================================
            let userGrid = Array.from({ length: gridSize }, () => Array(gridSize).fill(0)); // 0: vazio, 1: preenchido, 2: marcado (X)
            let currentPuzzleClues = { rowClues: [], colClues: [] }; 
            // =========================================================================

            // LÓGICA DE CARREGAMENTO DO JSON EXTERNO (Corrigida)
            // =========================================================================
            try {
                const response = await fetch('puzzles.json');
                
                if (!response.ok) {
                    throw new Error(`Erro HTTP! Status: ${response.status}. Certifique-se de que 'puzzles.json' existe.`);
                }
                
                puzzles = await response.json();

                if (puzzles.length === 0) {
                     throw new Error("O ficheiro 'puzzles.json' está vazio.");
                }

                loadRandomPuzzle();
            } catch (error) {
                console.error("Erro ao carregar os puzzles:", error);
                
                document.getElementById('game-board-container').innerHTML = 
                    '<div class="text-red-600 p-4 border border-red-300 bg-red-50 rounded-lg text-center mx-auto mt-10">' +
                    '<h3 class="font-bold text-lg mb-2">ERRO DE CARREGAMENTO</h3>' +
                    '<p>Não foi possível carregar os puzzles. Por favor, verifique:</p>' +
                    '<ul class="list-disc list-inside mt-2 text-left mx-auto max-w-sm">' +
                    '<li>Se o ficheiro <code class="font-mono bg-red-100 p-0.5 rounded">puzzles.json</code> existe na mesma pasta.</li>' +
                    '<li>Se está a executar o código num <strong>servidor local</strong> (Ex: Live Server do VS Code).</li>' +
                    '</ul></div>';
                
                document.getElementById('kanji-info').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                return; 
            }
            // =========================================================================


            // FUNÇÕES DO MINI-MAPA (Mantidas)
            function createMiniMap() {
                const miniMapGrid = document.getElementById('mini-map-grid');
                miniMapGrid.innerHTML = ''; 
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const miniCell = document.createElement('div');
                        miniCell.className = 'mini-cell';
                        miniCell.dataset.row = r;
                        miniCell.dataset.col = c;
                        miniMapGrid.appendChild(miniCell);
                    }
                }
            }

            function updateMiniMap(r, c, isFilled) {
                const miniCells = document.getElementById('mini-map-grid').children;
                const index = r * gridSize + c;
                const miniCell = miniCells[index];
                miniCell.classList.remove('mini-filled');
                if (isFilled) {
                    miniCell.classList.add('mini-filled');
                }
                
                const currentHighlight = document.querySelector('.mini-highlight');
                if (currentHighlight) {
                     currentHighlight.classList.remove('mini-highlight');
                }
                miniCell.classList.add('mini-highlight');
                miniMapContainer.style.opacity = '1';
            }

            function hideMiniMap() {
                miniMapContainer.style.opacity = '0';
                const currentHighlight = document.querySelector('.mini-highlight');
                if (currentHighlight) {
                     currentHighlight.classList.remove('mini-highlight');
                }
            }


            function generateClues(grid) {
                const rowClues = grid.map(row => {
                    let clues = []; let count = 0;
                    for (let cell of row) { if (cell === 1) { count++; } else { if (count > 0) { clues.push(count); } count = 0; } }
                    if (count > 0) { clues.push(count); } return clues.length > 0 ? clues : [0];
                });
                const colClues = [];
                for (let c = 0; c < gridSize; c++) {
                    let clues = []; let count = 0;
                    for (let r = 0; r < gridSize; r++) { if (grid[r][c] === 1) { count++; } else { if (count > 0) { clues.push(count); } count = 0; } }
                    if (count > 0) { clues.push(count); } colClues.push(clues.length > 0 ? clues : [0]);
                }
                return { rowClues, colClues };
            }

            function renderGrid(grid, rowClues, colClues) {
                board.innerHTML = '';
                
                // NOVO: Guardar as pistas e re-inicializar a grelha do utilizador
                currentPuzzleClues.rowClues = rowClues;
                currentPuzzleClues.colClues = colClues;
                userGrid = Array.from({ length: gridSize }, () => Array(gridSize).fill(0));
                
                const clueTopContainer = document.createElement('div');
                clueTopContainer.className = `clues-top grid grid-cols-${gridSize}`;
                clueTopContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                colClues.forEach((clueSet, index) => { // Adicionar 'index'
                    const clueDiv = document.createElement('div');
                    clueDiv.className = 'clue-cell';
                    clueDiv.dataset.colIndex = index; // Adicionar dataset para identificação
                    clueDiv.innerHTML = clueSet.map(c => `<span>${c}</span>`).join('<br>');
                    clueTopContainer.appendChild(clueDiv);
                });
                board.appendChild(clueTopContainer);

                const clueLeftContainer = document.createElement('div');
                clueLeftContainer.className = `clues-left grid grid-rows-${gridSize}`;
                clueLeftContainer.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
                rowClues.forEach((clueSet, index) => { // Adicionar 'index'
                    const clueDiv = document.createElement('div');
                    clueDiv.className = 'clue-cell';
                    clueDiv.dataset.rowIndex = index; // Adicionar dataset para identificação
                    clueDiv.innerHTML = clueSet.map(c => `<span>${c}</span>`).join('&nbsp;');
                    clueLeftContainer.appendChild(clueDiv);
                });
                board.appendChild(clueLeftContainer);

                const gameGrid = document.createElement('div');
                gameGrid.className = 'game-grid';
                gameGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
                gameGrid.style.gridTemplateRows = `repeat(${gridSize}, 1fr)`;
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell rounded-sm';
                        cell.dataset.row = r;
                        cell.dataset.col = c;
                        gameGrid.appendChild(cell);
                    }
                }
                board.appendChild(gameGrid);
                cells = gameGrid.querySelectorAll('.cell');
                
                checkClueCompletion(); // Verificar logo após o render (estado inicial vazio)
            }
            
            function checkWin() {
                for (let i = 0; i < cells.length; i++) {
                    const r = cells[i].dataset.row;
                    const c = cells[i].dataset.col;
                    const isFilled = cells[i].classList.contains('filled');
                    const isCorrect = currentGrid[r][c] === 1;

                    if ((isFilled && !isCorrect) || (!isFilled && isCorrect)) {
                        return false;
                    }
                }
                return true;
            }

            function showWinModal() {
                 const currentPuzzle = puzzles.find(p => JSON.stringify(p.grid) === JSON.stringify(currentGrid));
                 winKanji.textContent = currentPuzzle.kanji;
                 winMeaning.textContent = currentPuzzle.meaning;
                 winModal.style.opacity = '1';
                 winModal.style.pointerEvents = 'auto';
                 winModal.querySelector('div').style.transform = 'scale(1)';
            }
            function hideWinModal() {
                winModal.style.opacity = '0';
                winModal.style.pointerEvents = 'none';
                winModal.querySelector('div').style.transform = 'scale(0.95)';
            }
            
            // CORRIGIDO: Aplica a solução ao DOM e atualiza userGrid
            function solvePuzzle() {
                cells.forEach(cell => {
                    const r = parseInt(cell.dataset.row); 
                    const c = parseInt(cell.dataset.col);
                    
                    cell.classList.remove('filled');
                    cell.classList.remove('marked');

                    if (currentGrid[r][c] === 1) {
                        cell.classList.add('filled');
                        userGrid[r][c] = 1; // Atualiza userGrid para preenchido
                    } else {
                        cell.classList.add('marked');
                        userGrid[r][c] = 2; // Atualiza userGrid para marcado (X)
                    }
                    updateMiniMap(r, c, currentGrid[r][c] === 1);
                });
                
                checkClueCompletion(); // Verificar o estado das pistas após a solução
                
                if (checkWin()) { 
                    showWinModal(); 
                }
            }
            
            function loadRandomPuzzle() {
                const randomIndex = Math.floor(Math.random() * puzzles.length);
                const puzzle = puzzles[randomIndex];
                currentGrid = puzzle.grid;
                kanjiMeaning.textContent = puzzle.meaning;
                const { rowClues, colClues } = generateClues(currentGrid);
                renderGrid(currentGrid, rowClues, colClues);
                hideWinModal();
                
                createMiniMap(); 
            }
            
            // NOVO: Função para verificar se as pistas estão resolvidas
            function checkClueCompletion() {
                const clueTopCells = document.querySelectorAll('.clues-top .clue-cell');
                const clueLeftCells = document.querySelectorAll('.clues-left .clue-cell');

                // Função auxiliar para gerar pistas a partir do estado atual da grelha de uma dimensão
                const getCluesFromState = (stateArray) => {
                    let clues = []; 
                    let count = 0;
                    // Considera apenas as células preenchidas (1)
                    for (let cellState of stateArray) { 
                        if (cellState === 1) { 
                            count++; 
                        } else { 
                            if (count > 0) { 
                                clues.push(count); 
                            } 
                            count = 0; 
                        } 
                    }
                    if (count > 0) { 
                        clues.push(count); 
                    } 
                    return clues.length > 0 ? clues : [0];
                };
                
                // === 1. Verificar Pistas das LINHAS (Clues Left) ===
                currentPuzzleClues.rowClues.forEach((originalClues, r) => {
                    const rowState = userGrid[r];
                    const currentClues = getCluesFromState(rowState);
                    
                    const isComplete = JSON.stringify(originalClues) === JSON.stringify(currentClues);

                    const clueCell = Array.from(clueLeftCells).find(c => parseInt(c.dataset.rowIndex) === r);
                    if (clueCell) {
                        if (isComplete) {
                            clueCell.classList.add('completed');
                        } else {
                            clueCell.classList.remove('completed');
                        }
                    }
                });

                // === 2. Verificar Pistas das COLUNAS (Clues Top) ===
                currentPuzzleClues.colClues.forEach((originalClues, c) => {
                    const colState = [];
                    for (let r = 0; r < gridSize; r++) {
                        colState.push(userGrid[r][c]);
                    }
                    const currentClues = getCluesFromState(colState);
                    
                    const isComplete = JSON.stringify(originalClues) === JSON.stringify(currentClues);

                    const clueCell = Array.from(clueTopCells).find(clue => parseInt(clue.dataset.colIndex) === c);
                    if (clueCell) {
                        if (isComplete) {
                            clueCell.classList.add('completed');
                        } else {
                            clueCell.classList.remove('completed');
                        }
                    }
                });
            }


            // Lógica de Interação Touch/Mouse (CORRIGIDA)
            function handleCellInteraction(cell) {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                
                if (dragTargetState === null) {
                    // Define a ação (preencher/apagar ou marcar/desmarcar) apenas na primeira interação
                    if (currentTool === 'fill') {
                        dragTargetState = cell.classList.contains('filled') ? 'erase' : 'fill';
                    } else {
                        dragTargetState = cell.classList.contains('marked') ? 'unmark' : 'mark';
                    }
                }

                let isFilled = cell.classList.contains('filled');
                
                if (currentTool === 'fill') {
                    if (dragTargetState === 'fill') {
                        cell.classList.add('filled'); cell.classList.remove('marked');
                        isFilled = true;
                        userGrid[r][c] = 1; // Preenchido
                    } else { 
                        cell.classList.remove('filled'); cell.classList.remove('marked');
                        isFilled = false;
                        userGrid[r][c] = 0; // Vazio
                    }
                } else { 
                    if (dragTargetState === 'mark') {
                        cell.classList.add('marked'); cell.classList.remove('filled');
                        isFilled = false;
                        userGrid[r][c] = 2; // Marcado (X)
                    } else { 
                        cell.classList.remove('marked'); cell.classList.remove('filled');
                        isFilled = false;
                        userGrid[r][c] = 0; // Vazio
                    }
                }

                if (currentTool === 'fill' || (currentTool === 'mark' && dragTargetState !== 'mark')) {
                     updateMiniMap(
                        parseInt(cell.dataset.row), 
                        parseInt(cell.dataset.col), 
                        isFilled 
                    );
                }
                
                checkClueCompletion(); // Verificar o estado das pistas após a interação
            }
            
            // MOUSE EVENTS (Funcionam corretamente para clique e arrasto)
            board.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('cell')) {
                    isDragging = true; dragTargetState = null; 
                    handleCellInteraction(e.target);
                }
            });
            board.addEventListener('mouseup', () => { 
                isDragging = false; 
                dragTargetState = null; 
                hideMiniMap(); 
                if (checkWin()) { showWinModal(); } 
            });
            board.addEventListener('mouseover', (e) => {
                if (isDragging && e.target.classList.contains('cell')) {
                    handleCellInteraction(e.target);
                }
            });
            
            // TOUCH EVENTS (CORRIGIDOS para taps E long press)
            board.addEventListener('touchstart', (e) => {
                if (e.target.classList.contains('cell') && e.touches.length === 1) { 
                     e.preventDefault(); 
                     
                     // 1. Configurar estado inicial
                     isDragging = true;
                     isTap = true;
                     longPressExecuted = false; // Reset
                     tapCell = e.target;
                     dragTargetState = null;

                     // 2. Tentar executar a interação como "long press" após 500ms
                     if (pressTimeout) clearTimeout(pressTimeout);
                     pressTimeout = setTimeout(() => {
                         if (isTap && !longPressExecuted) { // Verifica se ainda é um tap e a ação não foi feita
                            handleCellInteraction(tapCell);
                            longPressExecuted = true;
                         }
                         // O touchend fará o checkWin, não o fazemos aqui.
                     }, 500); // 500ms para long press
                }
            });

            board.addEventListener('touchend', () => {
                // 1. Limpar timeout
                if (pressTimeout) {
                    clearTimeout(pressTimeout);
                    pressTimeout = null;
                }
                
                // 2. Executar apenas se foi um quick tap e a ação ainda não foi executada (não foi drag nem long press)
                if (isTap && tapCell && !longPressExecuted) { 
                     handleCellInteraction(tapCell);
                }

                // 3. Resetar estados
                isDragging = false;
                isTap = false;
                longPressExecuted = false;
                dragTargetState = null;
                tapCell = null;
                hideMiniMap(); 
                if (checkWin()) { showWinModal(); }
            });

            board.addEventListener('touchmove', (e) => {
                if (isDragging) {
                    // 1. Limpar timeout, pois é um arrasto
                    if (pressTimeout) {
                        clearTimeout(pressTimeout);
                        pressTimeout = null;
                    }

                    isTap = false; // Não é um toque
                    longPressExecuted = false; // Se arrastou, não é long press

                    e.preventDefault(); 
                    const touch = e.touches[0];
                    const target = document.elementFromPoint(touch.clientX, touch.clientY);
                    
                    if (target && target.classList.contains('cell')) {
                        handleCellInteraction(target); // Executa a ação imediatamente durante o arrasto
                    }
                }
            });
            
            // Controles de botão
            fillBtn.addEventListener('click', () => { currentTool = 'fill'; fillBtn.classList.add('active'); markBtn.classList.remove('active'); });
            markBtn.addEventListener('click', () => { currentTool = 'mark'; markBtn.classList.add('active'); fillBtn.classList.remove('active'); });
            
            resetBtn.addEventListener('click', () => { 
                const puzzleToReload = puzzles.find(p => JSON.stringify(p.grid) === JSON.stringify(currentGrid));
                const { rowClues, colClues } = generateClues(puzzleToReload.grid);
                renderGrid(puzzleToReload.grid, rowClues, colClues);
                hideWinModal();
                createMiniMap(); 
                checkClueCompletion(); // Chamar após o render para garantir que as classes de pista sejam limpas
            });
            
            solveBtn.addEventListener('click', solvePuzzle);
            nextBtn.addEventListener('click', loadRandomPuzzle);
            modalNextBtn.addEventListener('click', loadRandomPuzzle);
        });
    </script>
</body>
</html>
