<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pikranji - Web Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    
    <style>
        :root {
            /* Variáveis CSS que serão alteradas pelo JS */
            --ds-bg: #E0E8F8;        
            --ds-grid: #B0B8C8;      
            --ds-filled: #F85028;    
            --ds-cursor: #00C8F8;    
            --ds-text: #284060;      
            --ds-done: #A0A0A0;      
            --ds-panel: #ffffff;
        }

        html, body {
            height: 100%; margin: 0; padding: 0; overflow: hidden;
        }

        body { 
            font-family: 'VT323', monospace; 
            background-color: #202020;
            color: var(--ds-text);
            touch-action: none; 
            font-size: 1.2rem;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        
        #app-container {
            background-color: var(--ds-bg);
            width: 100%; max-width: 500px;
            height: 100dvh; 
            display: flex; flex-direction: column;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            position: relative;
            transition: background-color 0.5s ease;
        }

        .status-bar {
            background-color: var(--ds-text); /* Adapta-se ao tema */
            color: white;
            padding: 4px 10px;
            display: flex; justify-content: space-between;
            font-size: 1.0rem; flex-shrink: 0;
            transition: background-color 0.5s ease;
        }

        header {
            padding: 5px 10px;
            background-color: white;
            border-bottom: 2px solid var(--ds-grid);
            flex-shrink: 0;
            display: flex; justify-content: space-between; align-items: center;
        }

        main {
            flex-grow: 1;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            overflow-y: auto; padding: 10px; padding-bottom: 80px;
        }

        /* TABULEIRO */
        .board-container { 
            width: 90vw; height: 90vw; 
            max-width: 400px; max-height: 400px; 
            display: grid; 
            grid-template-columns: 30px 1fr; grid-template-rows: 30px 1fr; 
            gap: 0px; user-select: none; margin-bottom: 10px;
        }

        .clues-top { 
            grid-column: 2 / 3; grid-row: 1 / 2; 
            display: flex; justify-content: space-around; align-items: flex-end;
            background-color: #f0f4fc40; /* Ligeiramente transparente */
            border-bottom: 1px solid var(--ds-grid);
        }
        .clues-left { 
            grid-column: 1 / 2; grid-row: 2 / 3; 
            display: flex; flex-direction: column; justify-content: space-around; align-items: flex-end; 
            background-color: #f0f4fc40; 
            border-right: 1px solid var(--ds-grid);
            padding-right: 2px;
        }
        .clue-cell { 
            color: var(--ds-text); font-weight: bold; 
            display: flex; align-items: center; justify-content: center; 
            text-align: center; font-size: 0.8rem; line-height: 0.8;
            width: 100%; height: 100%;
            transition: color 0.3s;
        }
        
        /* Estilo para pistas completas */
        .clue-cell.completed { opacity: 0.5; }
        .clue-cell.completed span { 
            color: var(--ds-done); 
            text-decoration: line-through; 
            text-decoration-thickness: 2px;
        }

        .game-grid { 
            grid-column: 2 / 3; grid-row: 2 / 3; 
            display: grid; 
            grid-template-columns: repeat(15, 1fr); grid-template-rows: repeat(15, 1fr); 
            gap: 1px; 
            background-color: var(--ds-grid); 
            border: 2px solid var(--ds-text);
            cursor: crosshair;
        }
        
        .cell { background-color: white; width: 100%; height: 100%; position: relative; }
        .cell.filled { background-color: var(--ds-filled) !important; }
        .cell.marked::before { 
            content: '×'; color: var(--ds-text); position: absolute; 
            top: 50%; left: 50%; transform: translate(-50%, -50%); 
            font-size: 1.0em; line-height: 0;
        }

        /* CONTROLOS */
        #controls-area {
            position: absolute; bottom: 0; left: 0; width: 100%;
            background-color: var(--ds-bg);
            border-top: 2px solid var(--ds-text);
            padding: 10px; display: flex; justify-content: space-between; align-items: center;
            z-index: 100; padding-bottom: max(10px, env(safe-area-inset-bottom));
            transition: background-color 0.5s ease;
        }

        .control-btn {
            background-color: #eee; border: 2px solid var(--ds-text);
            box-shadow: 2px 2px 0px rgba(0,0,0,0.2); color: var(--ds-text);
            font-family: 'VT323', monospace; text-transform: uppercase;
            font-size: 1.2rem; padding: 5px 12px;
            transition: all 0.1s;
        }
        .control-btn:active { transform: translate(2px, 2px); box-shadow: none; }
        .control-btn.active-tool { background-color: var(--ds-cursor); color: white; border-color: #0088b0; }
        .action-btn { background-color: var(--ds-text); color: white; }

        /* MINI MAPA */
        #mini-map-container {
            position: fixed; top: 60px; right: 20px; width: 100px; height: 100px; 
            background-color: white; border: 3px solid var(--ds-text);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 9999; opacity: 0; 
            pointer-events: none; transition: opacity 0.2s;
        }
        .mini-cell { background-color: #eee; }
        .mini-filled { background-color: var(--ds-filled) !important; }

        #fx-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 50; }
        
        #win-modal .modal-content {
            background-color: var(--ds-bg); border: 4px solid var(--ds-text);
            box-shadow: 10px 10px 0px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>

    <div id="mini-map-container"><div id="mini-map-grid" style="display: grid; grid-template-columns: repeat(15, 1fr); width: 100%; height: 100%;"></div></div>

    <div id="app-container">
        <canvas id="fx-canvas"></canvas>

        <div class="status-bar">
            <span id="ui-score">Sc: 0</span>
            <span id="ui-unlock">Unl: 10</span>
        </div>
        
        <header>
            <div>
                <h1 class="text-2xl font-bold leading-none">PIKRANJI</h1>
                <span id="puzzle-status" class="text-xs font-bold text-red-500"></span>
            </div>
            <button id="lang-btn" class="control-btn text-xs py-1 px-2 h-8">[X] PT</button>
        </header>

        <main>
            <div class="w-full text-center mb-2">
                <p class="text-sm opacity-70" data-lang-key="meaningLabel">Significado:</p>
                <h2 id="kanji-meaning" class="text-3xl font-bold leading-none" style="color: var(--ds-text)">---</h2>
            </div>

            <div id="game-board" class="board-container"></div>
        </main>

        <div id="controls-area">
            <div class="flex gap-2">
                <button id="fill-btn" class="control-btn active-tool text-xl px-4">■</button>
                <button id="mark-btn" class="control-btn text-xl px-4">×</button>
            </div>
            <div class="flex gap-2">
                <button id="hint-btn" class="control-btn action-btn text-lg px-3">?</button>
                <button id="solve-btn" class="control-btn action-btn text-lg px-3">!</button>
                <button id="next-btn" class="control-btn text-sm px-2" data-lang-key="next">Sel</button>
            </div>
        </div>
    </div>

    <div id="win-modal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 transition-opacity duration-300 opacity-0 pointer-events-none z-50">
        <div class="modal-content bg-white p-6 text-center transform scale-95 transition-all duration-300 w-64">
            <h2 class="text-4xl font-bold mb-2 text-green-600 blink" data-lang-key="congrats">CLEAR!</h2>
            <div id="win-kanji" class="text-9xl font-black mb-2" style="color: var(--ds-filled)"></div>
            <p id="win-meaning" class="text-2xl font-bold mb-4"></p>
            <button id="modal-next-btn" class="control-btn w-full bg-indigo-600 text-white" data-lang-key="nextChallenge">Próximo</button>
        </div>
    </div>

    <script>
        // --- TEMAS (Cores convertidas do RGB15 da Nintendo DS) ---
        const THEMES = [
            { bg: "#E0E8F8", grid: "#B0B8C8", filled: "#F85028", cursor: "#00C8F8", text: "#284060", done: "#A0A0A0" }, // Padrão
            { bg: "#D0F0D0", grid: "#A0C0A0", filled: "#50C850", cursor: "#F8A050", text: "#287828", done: "#90B090" }, // Floresta
            { bg: "#C8E0F0", grid: "#A0B8C8", filled: "#28A0F8", cursor: "#F8C850", text: "#0050A0", done: "#90A0B0" }, // Oceano
            { bg: "#F0E0D0", grid: "#C8B8A8", filled: "#C86028", cursor: "#28A078", text: "#784028", done: "#C0B0A0" }, // Madeira
            { bg: "#E8D8F0", grid: "#C0B0C8", filled: "#A050C8", cursor: "#50F8A0", text: "#602878", done: "#B0A0B0" }, // Toxico
        ];

        function applyRandomTheme() {
            const t = THEMES[Math.floor(Math.random() * THEMES.length)];
            const root = document.documentElement.style;
            root.setProperty('--ds-bg', t.bg);
            root.setProperty('--ds-grid', t.grid);
            root.setProperty('--ds-filled', t.filled);
            root.setProperty('--ds-cursor', t.cursor);
            root.setProperty('--ds-text', t.text);
            root.setProperty('--ds-done', t.done);
        }

        // --- AUDIO SYSTEM ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            
            if (type === 'fill') { 
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now+0.1);
                osc.start(now); osc.stop(now+0.1);
            } else if (type === 'mark') { 
                osc.type = 'triangle'; osc.frequency.setValueAtTime(150, now);
                gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now+0.1);
                osc.start(now); osc.stop(now+0.1);
            } else if (type === 'win') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(523.25, now); osc.frequency.setValueAtTime(659.25, now+0.1);
                osc.frequency.setValueAtTime(783.99, now+0.2); osc.frequency.setValueAtTime(1046.50, now+0.3);
                gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now+0.6);
                osc.start(now); osc.stop(now+0.6);
            }
        }

        // --- PARTICLE SYSTEM ---
        const canvas = document.getElementById('fx-canvas');
        const ctx = canvas.getContext('2d');
        let particles = [];
        function resizeCanvas() { canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight; }
        window.addEventListener('resize', resizeCanvas); resizeCanvas();

        function triggerConfetti() {
            particles = [];
            const color = getComputedStyle(document.documentElement).getPropertyValue('--ds-filled').trim();
            for(let i=0; i<100; i++) {
                particles.push({
                    x: canvas.width / 2, y: canvas.height / 2,
                    vx: (Math.random() - 0.5) * 10, vy: (Math.random() - 0.5) * 10,
                    color: color, life: 100
                });
            }
            animateParticles();
        }

        function animateParticles() {
            if (particles.length === 0) { ctx.clearRect(0,0,canvas.width,canvas.height); return; }
            ctx.clearRect(0,0,canvas.width,canvas.height);
            particles.forEach((p, i) => {
                p.x += p.vx; p.y += p.vy; p.life--;
                ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 5, 5);
                if(p.life <= 0) particles.splice(i, 1);
            });
            requestAnimationFrame(animateParticles);
        }

        // --- GAME LOGIC ---
        document.addEventListener('DOMContentLoaded', async () => {
            const LANG_PT = 'pt'; const LANG_EN = 'en'; const GRID_SIZE = 15;
            let saveData = { score: 0, unlockedLimit: 10, solvedCount: 0, language: LANG_PT, solved: {} };
            const stored = localStorage.getItem('pikranji_save_v5');
            if (stored) saveData = JSON.parse(stored);

            let puzzles = [], puzzleBag = [], currentPuzzleID = 0;
            let currentGrid = [], userGrid = [], currentTool = 'fill';
            let gameWon = false, cheated = false;
            let currentPuzzleClues = { rowClues: [], colClues: [] };
            let domCells = [];

            const boardEl = document.getElementById('game-board');
            const uiScore = document.getElementById('ui-score');
            const uiUnlock = document.getElementById('ui-unlock');
            const uiMeaning = document.getElementById('kanji-meaning');
            const uiStatus = document.getElementById('puzzle-status');
            const langBtn = document.getElementById('lang-btn');
            const fillBtn = document.getElementById('fill-btn');
            const markBtn = document.getElementById('mark-btn');
            const miniMapGrid = document.getElementById('mini-map-grid');
            const miniMapContainer = document.getElementById('mini-map-container');
            const winModal = document.getElementById('win-modal');

            const translations = {
                pt: { meaningLabel: "Significado:", solve: "!", hint: "?", next: "Sel", congrats: "CLEAR!", nextChallenge: "Próximo", solved: "RESOLVIDO", cheated: "BATOTA" },
                en: { meaningLabel: "Meaning:", solve: "!", hint: "?", next: "Sel", congrats: "CLEAR!", nextChallenge: "Next", solved: "SOLVED", cheated: "CHEATED" }
            };

            try {
                const res = await fetch('puzzles.json');
                if (!res.ok) throw new Error();
                puzzles = await res.json();
                puzzles.forEach((p, i) => { p.id = i; p.complexity = p.grid.flat().filter(x => x === 1).length; });
                puzzles.sort((a,b) => a.complexity - b.complexity);
                createMiniMap();
                refreshUI();
                loadNextPuzzle(false);
            } catch (e) { console.error(e); uiMeaning.textContent = "ERRO JSON"; }

            function saveGame() { localStorage.setItem('pikranji_save_v5', JSON.stringify(saveData)); refreshUI(); }

            function loadNextPuzzle(force = false) {
                if (force || puzzleBag.length === 0) {
                    let limit = Math.min(saveData.unlockedLimit, puzzles.length);
                    puzzleBag = puzzles.slice(0, limit).map(p => p.id).sort(() => Math.random() - 0.5);
                }
                currentPuzzleID = puzzleBag.pop();
                const p = puzzles.find(x => x.id === currentPuzzleID);
                currentGrid = p.grid;
                userGrid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(0));
                gameWon = false; cheated = false;
                applyRandomTheme();
                renderGrid();
                hideWinModal();
                refreshUI();
            }

            function refreshUI() {
                const lang = saveData.language;
                const t = translations[lang];
                const p = puzzles.find(x => x.id === currentPuzzleID);
                document.querySelectorAll('[data-lang-key]').forEach(el => {
                    const key = el.getAttribute('data-lang-key');
                    if (t[key]) el.textContent = t[key];
                });
                langBtn.textContent = `[X] ${lang.toUpperCase()}`;
                uiScore.textContent = `Sc: ${saveData.score}`;
                uiUnlock.textContent = `Unl: ${Math.min(saveData.unlockedLimit, puzzles.length)}`;

                if (p) {
                    const mean = (lang === LANG_EN && p.meaning_en) ? p.meaning_en : p.meaning;
                    uiMeaning.textContent = mean;
                    document.getElementById('win-meaning').textContent = mean;
                    document.getElementById('win-kanji').textContent = p.kanji;
                }
                if (saveData.solved[currentPuzzleID]) uiStatus.textContent = t.solved;
                else if (cheated) uiStatus.textContent = t.cheated;
                else uiStatus.textContent = "";
            }

            // --- LÓGICA GRELHA + VERIFICAÇÃO DE PISTAS ---
            function renderGrid() {
                boardEl.innerHTML = '';
                domCells = [];

                const generate = (g) => {
                    const rC = g.map(row => { let c=[],n=0; for(let x of row){if(x===1)n++;else{if(n>0)c.push(n);n=0;}} if(n>0)c.push(n); return c.length?c:[0]; });
                    const cC = [];
                    for(let c=0;c<GRID_SIZE;c++){ let col=[],n=0; for(let r=0;r<GRID_SIZE;r++){if(g[r][c]===1)n++;else{if(n>0)col.push(n);n=0;}} if(n>0)col.push(n); cC.push(col.length?col:[0]); }
                    return {rC, cC};
                };
                const {rC, cC} = generate(currentGrid);
                currentPuzzleClues = {rowClues: rC, colClues: cC};

                const sp = document.createElement('div'); sp.style.backgroundColor="var(--ds-bg)"; boardEl.appendChild(sp);
                
                const topD = document.createElement('div'); topD.className=`clues-top grid grid-cols-${GRID_SIZE}`;
                topD.style.gridTemplateColumns=`repeat(${GRID_SIZE},1fr)`;
                cC.forEach(c => { 
                    const d=document.createElement('div'); d.className='clue-cell'; 
                    d.innerHTML=c.map(n=>`<span>${n}</span>`).join('<br>'); topD.appendChild(d); 
                });
                boardEl.appendChild(topD);

                const leftD = document.createElement('div'); leftD.className=`clues-left grid grid-rows-${GRID_SIZE}`;
                leftD.style.gridTemplateRows=`repeat(${GRID_SIZE},1fr)`;
                rC.forEach(c => { 
                    const d=document.createElement('div'); d.className='clue-cell'; 
                    d.innerHTML=c.map(n=>`<span>${n}</span>`).join('&nbsp;'); leftD.appendChild(d); 
                });
                boardEl.appendChild(leftD);

                const g = document.createElement('div'); g.className='game-grid';
                g.style.gridTemplateColumns=`repeat(${GRID_SIZE},1fr)`; g.style.gridTemplateRows=`repeat(${GRID_SIZE},1fr)`;
                for(let r=0;r<GRID_SIZE;r++) for(let c=0;c<GRID_SIZE;c++){
                    const cell=document.createElement('div'); cell.className='cell';
                    cell.dataset.r=r; cell.dataset.c=c;
                    g.appendChild(cell); domCells.push(cell);
                }
                boardEl.appendChild(g);
                checkClues(); // Verificar pistas no início (para casos de 0s)
            }

            function checkClues() {
                // Helpers
                const getRowClues = (r) => {
                    const arr = userGrid[r];
                    let c=[], n=0; for(let x of arr){if(x===1)n++;else{if(n>0)c.push(n);n=0;}} if(n>0)c.push(n); return c.length?c:[0];
                };
                const getColClues = (c) => {
                    let arr=[], n=0, cl=[]; for(let r=0;r<GRID_SIZE;r++) arr.push(userGrid[r][c]);
                    for(let x of arr){if(x===1)n++;else{if(n>0)cl.push(n);n=0;}} if(n>0)cl.push(n); return cl.length?cl:[0];
                };

                // DOM Elements
                const rowDivs = document.querySelectorAll('.clues-left .clue-cell');
                const colDivs = document.querySelectorAll('.clues-top .clue-cell');

                // Verificar Linhas
                currentPuzzleClues.rowClues.forEach((target, r) => {
                    const current = getRowClues(r);
                    if (JSON.stringify(target) === JSON.stringify(current)) rowDivs[r].classList.add('completed');
                    else rowDivs[r].classList.remove('completed');
                });

                // Verificar Colunas
                currentPuzzleClues.colClues.forEach((target, c) => {
                    const current = getColClues(c);
                    if (JSON.stringify(target) === JSON.stringify(current)) colDivs[c].classList.add('completed');
                    else colDivs[c].classList.remove('completed');
                });
            }

            function updateCell(r, c) {
                const cell = domCells[r*GRID_SIZE+c]; if(!cell) return;
                cell.className = 'cell';
                if(userGrid[r][c]===1) cell.classList.add('filled');
                if(userGrid[r][c]===2) cell.classList.add('marked');
            }

            function handleInteraction(r, c, isDrag) {
                if(gameWon) return;
                if(!isDrag) {
                    const v = userGrid[r][c];
                    if(currentTool === 'fill') dragTargetState = (v===1)?0:1;
                    else dragTargetState = (v===2)?0:2;
                }
                if(userGrid[r][c] !== dragTargetState) {
                    userGrid[r][c] = dragTargetState;
                    updateCell(r, c); updateMiniMap(r, c);
                    playSound(currentTool === 'fill' ? 'fill' : 'mark');
                    checkClues(); // <-- Verificar Pistas a cada interação
                    checkWin();
                }
            }

            function checkWin() {
                for(let r=0;r<GRID_SIZE;r++) for(let c=0;c<GRID_SIZE;c++) {
                    if ((userGrid[r][c]===1) !== (currentGrid[r][c]===1)) return;
                }
                if(!gameWon) {
                    gameWon = true;
                    playSound('win'); triggerConfetti();
                    if(!saveData.solved[currentPuzzleID] && !cheated) {
                        saveData.solved[currentPuzzleID] = true;
                        saveData.solvedCount++; saveData.score += 50;
                        if(saveData.solvedCount >= saveData.unlockedLimit - 2 && saveData.unlockedLimit < puzzles.length) saveData.unlockedLimit += 5;
                        saveGame();
                    }
                    showWinModal();
                }
            }

            function createMiniMap() {
                miniMapGrid.innerHTML = '';
                for(let i=0; i<GRID_SIZE*GRID_SIZE; i++) {
                    const d = document.createElement('div'); d.className='mini-cell';
                    miniMapGrid.appendChild(d);
                }
            }
            function updateMiniMap(r, c) {
                const idx = r*GRID_SIZE+c; const el = miniMapGrid.children[idx];
                if(el) { el.className = 'mini-cell'; if(userGrid[r][c]===1) el.classList.add('mini-filled'); }
                miniMapContainer.style.opacity = '1';
                clearTimeout(miniMapContainer.hideTimer);
                miniMapContainer.hideTimer = setTimeout(()=> miniMapContainer.style.opacity='0', 1500);
            }

            // --- INPUTS ---
            let isDraw = false, dragTargetState = 0;
            const onStart = (e) => {
                const t = e.touches ? e.touches[0] : e;
                const el = document.elementFromPoint(t.clientX, t.clientY);
                if(el && el.classList.contains('cell')) {
                    if(e.cancelable && e.type === 'touchstart') e.preventDefault();
                    isDraw = true;
                    handleInteraction(parseInt(el.dataset.r), parseInt(el.dataset.c), false);
                }
            };
            const onMove = (e) => {
                if(!isDraw) return;
                if(e.cancelable && e.type === 'touchmove') e.preventDefault();
                const t = e.touches ? e.touches[0] : e;
                const el = document.elementFromPoint(t.clientX, t.clientY);
                if(el && el.classList.contains('cell')) {
                    handleInteraction(parseInt(el.dataset.r), parseInt(el.dataset.c), true);
                }
            };

            boardEl.addEventListener('mousedown', onStart);
            boardEl.addEventListener('touchstart', onStart, {passive:false});
            window.addEventListener('mousemove', onMove);
            window.addEventListener('touchmove', onMove, {passive:false});
            window.addEventListener('mouseup', () => isDraw=false);
            window.addEventListener('touchend', () => isDraw=false);

            document.getElementById('fill-btn').onclick = function() { currentTool='fill'; this.classList.add('active-tool'); document.getElementById('mark-btn').classList.remove('active-tool'); };
            document.getElementById('mark-btn').onclick = function() { currentTool='mark'; this.classList.add('active-tool'); document.getElementById('fill-btn').classList.remove('active-tool'); };
            document.getElementById('lang-btn').onclick = () => { saveData.language = (saveData.language===LANG_PT)?LANG_EN:LANG_PT; saveGame(); };
            document.getElementById('next-btn').onclick = () => loadNextPuzzle(false);
            document.getElementById('solve-btn').onclick = () => { 
                if(gameWon) return; cheated=true; 
                userGrid = currentGrid.map(r=>r.map(c=>c===1?1:2)); 
                userGrid.forEach((r,ri)=>r.forEach((c,ci)=>updateCell(ri,ci))); 
                checkClues(); checkWin(); refreshUI(); 
            };
            document.getElementById('hint-btn').onclick = () => {
                if(gameWon) return;
                if(saveData.score > 0) {
                    saveData.score--; saveGame();
                    let attempts = 0;
                    while(attempts < 100) {
                        const r = Math.floor(Math.random()*GRID_SIZE), c = Math.floor(Math.random()*GRID_SIZE);
                        const target = currentGrid[r][c], current = userGrid[r][c];
                        if ((target === 1 && current !== 1) || (target === 0 && current === 1)) {
                            userGrid[r][c] = target === 1 ? 1 : 2;
                            updateCell(r, c); checkClues(); checkWin(); break;
                        }
                        attempts++;
                    }
                } else alert("Score insuficiente (1)");
            };
            document.addEventListener('keydown', e => { if(e.key.toLowerCase() === 'x') document.getElementById('lang-btn').click(); });

            function showWinModal() { winModal.style.opacity='1'; winModal.style.pointerEvents='auto'; }
            function hideWinModal() { winModal.style.opacity='0'; winModal.style.pointerEvents='none'; }
            document.getElementById('modal-next-btn').onclick = () => loadNextPuzzle(false);
            
            document.getElementById('reset-btn').onclick = () => {
                userGrid = Array.from({length: GRID_SIZE}, () => Array(GRID_SIZE).fill(0));
                domCells.forEach(c => { c.className='cell'; });
                checkClues();
            };
        });
    </script>
</body>
</html>
